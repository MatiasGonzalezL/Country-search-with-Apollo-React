{"ast":null,"code":"var parser = require('graphql/language/parser');\n\nvar parse = parser.parse; // Strip insignificant whitespace\n// Note that this could do a lot more, such as reorder fields etc.\n\nfunction normalize(string) {\n  return string.replace(/[\\s,]+/g, ' ').trim();\n} // A map docString -> graphql document\n\n\nvar docCache = {}; // A map fragmentName -> [normalized source]\n\nvar fragmentSourceMap = {};\n\nfunction cacheKeyFromLoc(loc) {\n  return normalize(loc.source.body.substring(loc.start, loc.end));\n} // For testing.\n\n\nfunction resetCaches() {\n  docCache = {};\n  fragmentSourceMap = {};\n} // Take a unstripped parsed document (query/mutation or even fragment), and\n// check all fragment definitions, checking for name->source uniqueness.\n// We also want to make sure only unique fragments exist in the document.\n\n\nvar printFragmentWarnings = true;\n\nfunction processFragments(ast) {\n  var astFragmentMap = {};\n  var definitions = [];\n\n  for (var i = 0; i < ast.definitions.length; i++) {\n    var fragmentDefinition = ast.definitions[i];\n\n    if (fragmentDefinition.kind === 'FragmentDefinition') {\n      var fragmentName = fragmentDefinition.name.value;\n      var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc); // We know something about this fragment\n\n      if (fragmentSourceMap.hasOwnProperty(fragmentName) && !fragmentSourceMap[fragmentName][sourceKey]) {\n        // this is a problem because the app developer is trying to register another fragment with\n        // the same name as one previously registered. So, we tell them about it.\n        if (printFragmentWarnings) {\n          console.warn(\"Warning: fragment with name \" + fragmentName + \" already exists.\\n\" + \"graphql-tag enforces all fragment names across your application to be unique; read more about\\n\" + \"this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names\");\n        }\n\n        fragmentSourceMap[fragmentName][sourceKey] = true;\n      } else if (!fragmentSourceMap.hasOwnProperty(fragmentName)) {\n        fragmentSourceMap[fragmentName] = {};\n        fragmentSourceMap[fragmentName][sourceKey] = true;\n      }\n\n      if (!astFragmentMap[sourceKey]) {\n        astFragmentMap[sourceKey] = true;\n        definitions.push(fragmentDefinition);\n      }\n    } else {\n      definitions.push(fragmentDefinition);\n    }\n  }\n\n  ast.definitions = definitions;\n  return ast;\n}\n\nfunction disableFragmentWarnings() {\n  printFragmentWarnings = false;\n}\n\nfunction stripLoc(doc, removeLocAtThisLevel) {\n  var docType = Object.prototype.toString.call(doc);\n\n  if (docType === '[object Array]') {\n    return doc.map(function (d) {\n      return stripLoc(d, removeLocAtThisLevel);\n    });\n  }\n\n  if (docType !== '[object Object]') {\n    throw new Error('Unexpected input.');\n  } // We don't want to remove the root loc field so we can use it\n  // for fragment substitution (see below)\n\n\n  if (removeLocAtThisLevel && doc.loc) {\n    delete doc.loc;\n  } // https://github.com/apollographql/graphql-tag/issues/40\n\n\n  if (doc.loc) {\n    delete doc.loc.startToken;\n    delete doc.loc.endToken;\n  }\n\n  var keys = Object.keys(doc);\n  var key;\n  var value;\n  var valueType;\n\n  for (key in keys) {\n    if (keys.hasOwnProperty(key)) {\n      value = doc[keys[key]];\n      valueType = Object.prototype.toString.call(value);\n\n      if (valueType === '[object Object]' || valueType === '[object Array]') {\n        doc[keys[key]] = stripLoc(value, true);\n      }\n    }\n  }\n\n  return doc;\n}\n\nvar experimentalFragmentVariables = false;\n\nfunction parseDocument(doc) {\n  var cacheKey = normalize(doc);\n\n  if (docCache[cacheKey]) {\n    return docCache[cacheKey];\n  }\n\n  var parsed = parse(doc, {\n    experimentalFragmentVariables: experimentalFragmentVariables\n  });\n\n  if (!parsed || parsed.kind !== 'Document') {\n    throw new Error('Not a valid GraphQL document.');\n  } // check that all \"new\" fragments inside the documents are consistent with\n  // existing fragments of the same name\n\n\n  parsed = processFragments(parsed);\n  parsed = stripLoc(parsed, false);\n  docCache[cacheKey] = parsed;\n  return parsed;\n}\n\nfunction enableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = true;\n}\n\nfunction disableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = false;\n} // XXX This should eventually disallow arbitrary string interpolation, like Relay does\n\n\nfunction\n  /* arguments */\ngql() {\n  var args = Array.prototype.slice.call(arguments);\n  var literals = args[0]; // We always get literals[0] and then matching post literals for each arg given\n\n  var result = typeof literals === \"string\" ? literals : literals[0];\n\n  for (var i = 1; i < args.length; i++) {\n    if (args[i] && args[i].kind && args[i].kind === 'Document') {\n      result += args[i].loc.source.body;\n    } else {\n      result += args[i];\n    }\n\n    result += literals[i];\n  }\n\n  return parseDocument(result);\n} // Support typescript, which isn't as nice as Babel about default exports\n\n\ngql.default = gql;\ngql.resetCaches = resetCaches;\ngql.disableFragmentWarnings = disableFragmentWarnings;\ngql.enableExperimentalFragmentVariables = enableExperimentalFragmentVariables;\ngql.disableExperimentalFragmentVariables = disableExperimentalFragmentVariables;\nmodule.exports = gql;","map":{"version":3,"names":["parser","require","parse","normalize","string","replace","trim","docCache","fragmentSourceMap","cacheKeyFromLoc","loc","source","body","substring","start","end","resetCaches","printFragmentWarnings","processFragments","ast","astFragmentMap","definitions","i","length","fragmentDefinition","kind","fragmentName","name","value","sourceKey","hasOwnProperty","console","warn","push","disableFragmentWarnings","stripLoc","doc","removeLocAtThisLevel","docType","Object","prototype","toString","call","map","d","Error","startToken","endToken","keys","key","valueType","experimentalFragmentVariables","parseDocument","cacheKey","parsed","enableExperimentalFragmentVariables","disableExperimentalFragmentVariables","gql","args","Array","slice","arguments","literals","result","default","module","exports"],"sources":["C:/Users/matia/OneDrive/Escritorio/dev-challenge-template-master/kimchechallenge/node_modules/graphql-tag/src/index.js"],"sourcesContent":["var parser = require('graphql/language/parser');\n\nvar parse = parser.parse;\n\n// Strip insignificant whitespace\n// Note that this could do a lot more, such as reorder fields etc.\nfunction normalize(string) {\n  return string.replace(/[\\s,]+/g, ' ').trim();\n}\n\n// A map docString -> graphql document\nvar docCache = {};\n\n// A map fragmentName -> [normalized source]\nvar fragmentSourceMap = {};\n\nfunction cacheKeyFromLoc(loc) {\n  return normalize(loc.source.body.substring(loc.start, loc.end));\n}\n\n// For testing.\nfunction resetCaches() {\n  docCache = {};\n  fragmentSourceMap = {};\n}\n\n// Take a unstripped parsed document (query/mutation or even fragment), and\n// check all fragment definitions, checking for name->source uniqueness.\n// We also want to make sure only unique fragments exist in the document.\nvar printFragmentWarnings = true;\nfunction processFragments(ast) {\n  var astFragmentMap = {};\n  var definitions = [];\n\n  for (var i = 0; i < ast.definitions.length; i++) {\n    var fragmentDefinition = ast.definitions[i];\n\n    if (fragmentDefinition.kind === 'FragmentDefinition') {\n      var fragmentName = fragmentDefinition.name.value;\n      var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);\n\n      // We know something about this fragment\n      if (fragmentSourceMap.hasOwnProperty(fragmentName) && !fragmentSourceMap[fragmentName][sourceKey]) {\n\n        // this is a problem because the app developer is trying to register another fragment with\n        // the same name as one previously registered. So, we tell them about it.\n        if (printFragmentWarnings) {\n          console.warn(\"Warning: fragment with name \" + fragmentName + \" already exists.\\n\"\n            + \"graphql-tag enforces all fragment names across your application to be unique; read more about\\n\"\n            + \"this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names\");\n        }\n\n        fragmentSourceMap[fragmentName][sourceKey] = true;\n\n      } else if (!fragmentSourceMap.hasOwnProperty(fragmentName)) {\n        fragmentSourceMap[fragmentName] = {};\n        fragmentSourceMap[fragmentName][sourceKey] = true;\n      }\n\n      if (!astFragmentMap[sourceKey]) {\n        astFragmentMap[sourceKey] = true;\n        definitions.push(fragmentDefinition);\n      }\n    } else {\n      definitions.push(fragmentDefinition);\n    }\n  }\n\n  ast.definitions = definitions;\n  return ast;\n}\n\nfunction disableFragmentWarnings() {\n  printFragmentWarnings = false;\n}\n\nfunction stripLoc(doc, removeLocAtThisLevel) {\n  var docType = Object.prototype.toString.call(doc);\n\n  if (docType === '[object Array]') {\n    return doc.map(function (d) {\n      return stripLoc(d, removeLocAtThisLevel);\n    });\n  }\n\n  if (docType !== '[object Object]') {\n    throw new Error('Unexpected input.');\n  }\n\n  // We don't want to remove the root loc field so we can use it\n  // for fragment substitution (see below)\n  if (removeLocAtThisLevel && doc.loc) {\n    delete doc.loc;\n  }\n\n  // https://github.com/apollographql/graphql-tag/issues/40\n  if (doc.loc) {\n    delete doc.loc.startToken;\n    delete doc.loc.endToken;\n  }\n\n  var keys = Object.keys(doc);\n  var key;\n  var value;\n  var valueType;\n\n  for (key in keys) {\n    if (keys.hasOwnProperty(key)) {\n      value = doc[keys[key]];\n      valueType = Object.prototype.toString.call(value);\n\n      if (valueType === '[object Object]' || valueType === '[object Array]') {\n        doc[keys[key]] = stripLoc(value, true);\n      }\n    }\n  }\n\n  return doc;\n}\n\nvar experimentalFragmentVariables = false;\nfunction parseDocument(doc) {\n  var cacheKey = normalize(doc);\n\n  if (docCache[cacheKey]) {\n    return docCache[cacheKey];\n  }\n\n  var parsed = parse(doc, { experimentalFragmentVariables: experimentalFragmentVariables });\n  if (!parsed || parsed.kind !== 'Document') {\n    throw new Error('Not a valid GraphQL document.');\n  }\n\n  // check that all \"new\" fragments inside the documents are consistent with\n  // existing fragments of the same name\n  parsed = processFragments(parsed);\n  parsed = stripLoc(parsed, false);\n  docCache[cacheKey] = parsed;\n\n  return parsed;\n}\n\nfunction enableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = true;\n}\n\nfunction disableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = false;\n}\n\n// XXX This should eventually disallow arbitrary string interpolation, like Relay does\nfunction gql(/* arguments */) {\n  var args = Array.prototype.slice.call(arguments);\n\n  var literals = args[0];\n\n  // We always get literals[0] and then matching post literals for each arg given\n  var result = (typeof(literals) === \"string\") ? literals : literals[0];\n\n  for (var i = 1; i < args.length; i++) {\n    if (args[i] && args[i].kind && args[i].kind === 'Document') {\n      result += args[i].loc.source.body;\n    } else {\n      result += args[i];\n    }\n\n    result += literals[i];\n  }\n\n  return parseDocument(result);\n}\n\n// Support typescript, which isn't as nice as Babel about default exports\ngql.default = gql;\ngql.resetCaches = resetCaches;\ngql.disableFragmentWarnings = disableFragmentWarnings;\ngql.enableExperimentalFragmentVariables = enableExperimentalFragmentVariables;\ngql.disableExperimentalFragmentVariables = disableExperimentalFragmentVariables;\n\nmodule.exports = gql;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}